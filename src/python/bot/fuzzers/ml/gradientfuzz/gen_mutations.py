# Copyright 2020 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
################################################################################
"""libFuzzer Neural Smoothing - Mutation Generation."""

import glob
import json
import math
import os
import sys
import threading

import numpy as np
import tqdm

import bot.fuzzers.ml.gradientfuzz.constants as constants
import bot.fuzzers.ml.gradientfuzz.libfuzzer_to_numpy as libfuzzer_to_numpy
import bot.fuzzers.ml.gradientfuzz.opts as opts


def write_numpy_to_bytefile(numpy_out, output_file_path):
    """
      Writes numpy byte array to specified output file. Sanity-checked
      with Linux diff tool.

      Args:
          numpy_out (np.ndarray): Array of bytes (entries in range 0-255) to be
              dumped.
          output_file_path (str): Full file path to save byte dump to.

      Returns:
          N/A
      """
    bytes_out = bytes(list(numpy_out))
    with open(output_file_path, "wb") as output_file:
        output_file.write(bytes_out)


def extract_ranges(mut_range_idx, critical_indices, seed_file_numpy):
    """
      Extracts the appropriate mutation range based on the current
      `mut_range_idx`, and the corresponding indices and bytes to be
      mutated.

      Args:
          mut_range_idx (int): Determines start/end indices for critical
              locations to mutate.
          critical_indices (np.ndarray): Indices generated by
              `gradient_gen_critical_locs.py` at which to mutate.
          seed_file_numpy (np.ndarray): Numpy array of raw input bytes.

      Returns:
          mut_range (list): Range of critical location indices at which to mutate.
          considered_indices (np.ndarray): Indices at which to mutate.
          considered_bytes (np.ndarray): Current input byte values at
              `considered_indices`.
      """
    mut_range = list(
        range(
            constants.NEUZZ_MUT_IDX_RANGES[mut_range_idx],
            constants.NEUZZ_MUT_IDX_RANGES[mut_range_idx + 1],
        )
    )
    considered_indices = critical_indices[mut_range]
    considered_bytes = seed_file_numpy[considered_indices]

    return mut_range, considered_indices, considered_bytes


def get_signs_and_limits(mut_range, considered_bytes):
    """
      Grabs a random vector of signs in {-1, +1}^{len(mut_range)}
      to repeatedly add to `considered_indices`, and returns the min
      number of iterations needed in either direction to completely
      saturate all bytes in `considered_bytes`.

      Args:
          mut_range (list): Range of critical location indices at which to mutate.

      Returns:
          signs (np.ndarrray): Vector in {-1, +1}^{len(mut_range)} which
              gets repeatedly added/subtracted from `considered_bytes` until
              saturation.
          positive_iter_limit (int): Minimum number of times `signs` must be
              added to `considered_bytes` to saturate.
          negative_iter_limit (int): Minimum number of times `signs` must be
              subtracted from `considered_bytes` to saturate.
      """

    # {Add, Subtract} until we get to {255, 0} for each byte considered.
    signs = np.random.choice([-1, 1], size=len(mut_range), replace=True)
    positive_limits = np.asarray(
        [(constants.MAX_BYTE_VAL if x == 1 else constants.MIN_BYTE_VAL) for x in signs]
    )
    negative_limits = constants.MAX_BYTE_VAL - positive_limits

    # How many times we have to iterate \pm 1 until all considered bytes
    # are saturated (i.e. either 0 or 255).
    positive_iter_limit = np.max(np.abs(positive_limits - considered_bytes))
    negative_iter_limit = np.max(np.abs(negative_limits - considered_bytes))

    return signs, positive_iter_limit, negative_iter_limit


def perform_neuzz_mutation(
    seed_file_numpy,
    mut_range,
    branch_idx,
    iter_limit,
    considered_indices,
    mutations_dir,
    seed_file_name,
    signs,
    positive,
):
    """
      Makes a copy of `seed_file_numpy` and adds/subtracts `signs`
      to seed_file[considered_indices] for `iter_limit` iterations,
      i.e. until saturated. Saves each mutation to a separate file.

      Args:
          seed_file_numpy (np.ndarray): Numpy array of raw input bytes.
          mut_range (list): Range of critical location indices at which to mutate.
          branch_idx (int): Which output branch gradients were taken
              with respect to.
          iter_limit (int): Minimum number of times `signs` must be added/
              subtracted to saturate.
          considered_indices (np.ndarray): Indices at which to mutate.
          mutations_dir (str): Directory to write mutated files to.
          seed_file_name (str): Basename (no extension) of the seed file
              being mutated.
          signs (np.ndarray): Vector in {-1, +1}^{len(mut_range)} which
              gets repeatedly added/subtracted from seed_file[considered_indices]
              until saturation.
          positive (bool): Whether to add or subtract `signs`.

      Returns:
          N/A (saves mutated outputs to generated/[generation-name]/mutations).
      """
    actual_signs = signs if positive else -1 * signs
    mutation_prefix = (
        constants.PLUS_MUTATION_PREFIX if positive else constants.MINUS_MUTATION_PREFIX
    )
    seed_file_copy = seed_file_numpy.copy()

    # Iterate until saturated. Add `actual_signs` and save to appropriate path.
    for plus_iter in range(iter_limit):
        seed_file_copy[considered_indices] += actual_signs
        seed_file_copy[considered_indices] = np.clip(
            seed_file_copy[considered_indices],
            a_max=constants.MAX_BYTE_VAL,
            a_min=constants.MIN_BYTE_VAL,
        )
        save_path = os.path.join(
            mutations_dir, mutation_prefix + seed_file_name
        ).format(branch_idx=branch_idx, start=mut_range[0], num=plus_iter)
        write_numpy_to_bytefile(seed_file_copy, save_path)


def mutate_one_like_neuzz(
    seed_file_numpy, ordered_indices, mutations_dir, seed_file_name
):
    """
      Mutates a single seed file. Emulates mutations performed in
      https://github.com/Dongdongshe/neuzz/blob/2c7179557a491266ca1478e5f8c431d0b69d3e3a/neuzz.c#L1155.

      In particular, for each seed file, for each range of critical locations
      (as specified by constants.NEUZZ_MUT_IDX_RANGES), the following happens:
          > Find the critical locations within the seed file.
          > Generate a random sign {-1, +1} for each critical location.
          > Until all critical bytes (i.e. bytes at critical locations) are
              saturated (i.e. either 0 or 255), add sign[location] to each
              critical byte, and save resulting byte array as a mutated output.

      Args:
          seed_file_numpy (np.ndarray): Numpy array version of the
              seed file's bytes.
          ordered_indices (np.ndarray): Numpy array containing rows of critical
              locs, ordered by their respective gradient component magnitudes.
          mutations_dir (str): Directory to write mutated files to.
          seed_file_name (str): Raw basename (no extension) of the
              seed file to be mutated.


      Returns:
          N/A (mutated files are saved under
              generated/[generation-name]/mutations)
      """
    for idx, critical_indices in enumerate(ordered_indices):
        for mut_range_idx in range(len(constants.NEUZZ_MUT_IDX_RANGES) - 1):

            # Extract mutation ranges, get subset of critical bytes/locations,
            # and generate mutations until all are saturated.
            mut_range, considered_indices, considered_bytes = extract_ranges(
                mut_range_idx, critical_indices, seed_file_numpy
            )
            signs, positive_iter_limit, negative_iter_limit = get_signs_and_limits(
                mut_range, considered_bytes
            )
            perform_neuzz_mutation(
                seed_file_numpy,
                mut_range,
                idx,
                positive_iter_limit,
                considered_indices,
                mutations_dir,
                seed_file_name,
                signs,
                True,
            )
            perform_neuzz_mutation(
                seed_file_numpy,
                mut_range,
                idx,
                negative_iter_limit,
                considered_indices,
                mutations_dir,
                seed_file_name,
                signs,
                False,
            )


def mutate_one_limited_neighborhood(
    seed_file_numpy,
    ordered_indices,
    mutations_dir,
    seed_file_name,
    num_mutations,
    neighborhood_max_width,
    arith_min,
    arith_max,
):
    """
      Generates mutations by picking a random subset of the top-k indices
      from a random branch and adding/subtracting random bytes within a
      limited range.

      Args:
          seed_file_numpy (np.ndarray): Np array version of the seed file bytes.
          ordered_indices (np.ndarray): Numpy array containing rows of critical
              locations, ordered by respective gradient component magnitudes.
          mutations_dir (str): Directory to write mutated files to.
          seed_file_name (str): Raw basename (no extension) of the seed file
              to be mutated.
          num_mutations (int): Number of mutated files to save.
          neighborhood_max_width (int): Maximum number of bytes
              (in either direction) to mutate around a critical location.
          arith_min (int): Smallest possible additive mutation to any
              critical byte.
          arith_max (int): Largest possible additive mutation to any critical byte
              (See line 123 in constants.py for information on defaults).


      Returns:
          N/A (mutated files are saved under
              generated/[generation-name]/mutations)
      """
    for mutation_num in range(num_mutations):
        seed_file_copy = seed_file_numpy.copy()
        branch_idx = np.random.randint(0, high=len(ordered_indices))
        which_indices = np.random.choice(
            ordered_indices[branch_idx],
            size=np.random.randint(1, high=len(ordered_indices[branch_idx])),
            replace=False,
        )

        # Picks randomly-sized neighborhoods around each critical location.
        if neighborhood_max_width > 0:
            widths = np.random.randint(
                low=0, high=neighborhood_max_width + 1, size=which_indices.shape
            )
            which_indices = np.concatenate(
                [
                    list(
                        range(
                            max(0, crit_idx - width),
                            min(crit_idx + width + 1, len(seed_file_copy)),
                        )
                    )
                    for (crit_idx, width) in zip(which_indices, widths)
                ]
            )

        # New byte values should be uniform over [0, 255].
        change_by = np.random.randint(arith_min, arith_max + 1, size=len(which_indices))
        seed_file_copy[which_indices] = (
            seed_file_copy[which_indices] + change_by
        ) % constants.MAX_BYTE_VAL

        save_path = os.path.join(
            mutations_dir, constants.GENERIC_MUTATION_PREFIX + seed_file_name
        ).format(branch_idx=branch_idx, num=mutation_num)
        write_numpy_to_bytefile(seed_file_copy, save_path)


def mutate_one_simple_random(
    seed_file_numpy, ordered_indices, mutations_dir, seed_file_name, num_mutations
):
    """
      Generates mutations by picking a random subset of the top-k indices
      from a random branch and adding/subtracting random amounts to each
      critical byte.

      Args:
          seed_file_numpy (np.ndarray): Np array version of the seed file bytes.
          ordered_indices (np.ndarray): Numpy array containing rows of critical
              locations, ordered by respective gradient component magnitudes.
          mutations_dir (str): Directory to write mutated files to.
          seed_file_name (str): Raw basename (no extension) of the seed file
              to be mutated.
          num_mutations (int): Number of mutated files to save.


      Returns:
          N/A (mutated files are saved under
              generated/[generation-name]/mutations)
      """
    for mutation_num in range(num_mutations):
        seed_file_copy = seed_file_numpy.copy()
        branch_idx = np.random.randint(0, high=len(ordered_indices))
        which_indices = np.random.choice(
            ordered_indices[branch_idx],
            size=np.random.randint(0, high=len(ordered_indices[branch_idx])),
            replace=False,
        )

        # New byte values should be uniform over [0, 255].
        change_by = np.random.randint(
            constants.MIN_BYTE_VAL, constants.MAX_BYTE_VAL, size=len(which_indices)
        )
        seed_file_copy[which_indices] = (
            seed_file_copy[which_indices] + change_by
        ) % constants.MAX_BYTE_VAL

        save_path = os.path.join(
            mutations_dir, constants.GENERIC_MUTATION_PREFIX + seed_file_name
        ).format(branch_idx=branch_idx, num=mutation_num)
        write_numpy_to_bytefile(seed_file_copy, save_path)


def mutation_gen_loop(
    start_idx,
    end_idx,
    ordered_index_file_paths,
    seed_file_paths,
    seed_file_mapping,
    mutations_dir,
    input_length_mapping,
    args,
    first=False,
):
    """
      Iterates through each critical index file and mutates the original inputs.

      Args:
          start_idx (int): Process files beginning at this index
              (for multithreading; inclusive).
          end_idx (int): Process files ending at this index
              (for multithreading; exclusive).
          ordered_index_file_paths (list): List of critical location file paths.
          seed_file_paths (list): List of full paths to all seed files.
          seed_file_mapping (dict): Maps critical location file to seed file.
          mutations_dir (str): Where mutated files get saved.
          input_length_mapping (dict): Dictionary of input paths to
              input byte lengths.
          args (argparse.Namespace): Arguments passed into
              `get_gen_mutations_args()` (opts.py).
          first (bool): Whether to display the tqdm progress bar.

      Returns:
          N/A
      """
    this_thread_file_paths = ordered_index_file_paths[start_idx:end_idx]
    iterator = tqdm.tqdm(this_thread_file_paths) if first else this_thread_file_paths
    for gradient_file_path in iterator:
        seed_file_name = os.path.basename(gradient_file_path)

        if seed_file_name == constants.METADATA_FILENAME:
            continue

        seed_file_length = int(input_length_mapping[seed_file_name])
        seed_file_path = seed_file_paths[seed_file_mapping[seed_file_name]]
        seed_file_numpy = libfuzzer_to_numpy.convert_input_to_numpy(seed_file_path)[
            :seed_file_length
        ]
        ordered_indices = np.load(gradient_file_path).astype(np.int32)
        seed_file_name = seed_file_name[: seed_file_name.rfind(".npy")]

        if args.mutation_gen_method == constants.NEUZZ_MUTATION:
            mutate_one_like_neuzz(
                seed_file_numpy, ordered_indices, mutations_dir, seed_file_name
            )

        elif args.mutation_gen_method == constants.SIMPLE_RANDOM:
            mutate_one_simple_random(
                seed_file_numpy,
                ordered_indices,
                mutations_dir,
                seed_file_name,
                args.num_mutations,
            )

        elif args.mutation_gen_method == constants.LIMITED_NEIGHBORHOOD:
            mutate_one_limited_neighborhood(
                seed_file_numpy,
                ordered_indices,
                mutations_dir,
                seed_file_name,
                args.num_mutations,
                args.neighborhood_max_width,
                args.arith_min,
                args.arith_max,
            )

        # Also save a copy of the original.
        orig_save_path = os.path.join(
            mutations_dir, constants.ORIGINAL_PREFIX + seed_file_name
        )
        write_numpy_to_bytefile(seed_file_numpy, orig_save_path)


def generate_mutations(args, gradient_metadata, gradients_dir, mutations_dir):
    """
      Generates mutations from input files as specified by
          metadata['path_to_seeds'].

      Args:
          args (argparse.Namespace): Arguments as specified by
              `get_gen_mutations_args()` in opts.py.
          gradient_metadata (dict): Metadata as constructed in
              gradient_gen_critical_locs.py. See documentation for
              `generate_all_critical_locs()`.
          gradients_dir (str): Directory from which to pull
              critical locations files.
          mutations_dir (str): Directory to write mutated files to.

      Returns:
          N/A
      """
    seed_file_paths = list(
        glob.glob(os.path.join(gradient_metadata["path_to_seeds"], "*"))
    )
    seed_file_mapping = {}
    for idx, seed_path in enumerate(seed_file_paths):
        seed_file_mapping[os.path.basename(seed_path)] = idx
    input_length_mapping = json.load(open(args.path_to_lengths, "r"))

    ordered_index_file_paths = list(glob.glob(os.path.join(gradients_dir, "*")))

    # Standard multithreading to speed up mutation generation.
    num_threads = os.cpu_count()
    workers = [None] * num_threads
    num_inputs_per_worker = math.ceil(len(ordered_index_file_paths) / num_threads)

    for worker_idx, _ in enumerate(workers):
        start_idx = worker_idx * num_inputs_per_worker
        end_idx = min(
            len(ordered_index_file_paths), (worker_idx + 1) * num_inputs_per_worker
        )
        workers[worker_idx] = threading.Thread(
            target=mutation_gen_loop,
            args=(
                start_idx,
                end_idx,
                ordered_index_file_paths,
                seed_file_paths,
                seed_file_mapping,
                mutations_dir,
                input_length_mapping,
                args,
                worker_idx == 0,
            ),
        )
        workers[worker_idx].start()

    for worker in workers:
        worker.join()


def main():
    """
      Uses generated critical location data from gradient_gen_critical_locs.py
      to perform mutations and save mutated files.

      Args:
          N/A

      Returns:
          N/A (generated files saved to generated/[generation-name]/mutations)
      """
    args = opts.get_gen_mutations_args()

    # Setting up directory tree and reading metadata in.
    generated_dir = os.path.join(constants.GENERATED_DIR, args.generation_name)
    if not os.path.isdir(generated_dir):
        print(
            (
                "Error: Cannot locate directory {}. "
                + "(Did you run gradient_gen_critical_locs.py first?)"
            ).format(generated_dir)
        )
        sys.exit()
    gradients_dir = os.path.join(generated_dir, constants.GRADIENTS_DIR)
    mutations_dir = os.path.join(
        generated_dir, constants.MUTATIONS_DIR, args.mutation_name
    )
    if os.path.isdir(mutations_dir):
        print(
            (
                "Error: {} already exists! (Did you already run gen_mutations.py "
                + "on {} with name {}?)"
            ).format(mutations_dir, args.generation_name, args.mutation_name)
        )
        sys.exit()
    os.makedirs(mutations_dir)
    print("Writing mutated inputs to {}".format(mutations_dir))

    # Gets metadata from critical location generation.
    metadata_filepath = os.path.join(gradients_dir, constants.METADATA_FILENAME)
    gradient_metadata = json.load(open(metadata_filepath, "r"))

    if opts.check_gen_mutations_args(args):
        generate_mutations(args, gradient_metadata, gradients_dir, mutations_dir)


if __name__ == "__main__":
    main()
